In process:
Set termination condition:
    -implement check_end_conditions: printf, sleep, pending the rest (check gemini chat up)
    -INITIALIZED monitor thread does it need mutex?
    -Connect monitor with philos to see if that will organized them

Next:
life cycle:
check how to debu threads in gdb 

5. Correct the output formatting in which is printed, I am using printf

6. Make the functions to grab both forks before eating

9. Debug in make

10. Set-up copilot

11. Handle case with 1 philo

12. check edge cases
    
ALLWAYS
test
Split into files

Done:
init_cross_mutex
init_forks
init_program with args
init_philos
printf_mutex
set-up simulation
life cycle:
    basic philo_sleep
    basic philo_think
    think after sleep
include the struct arg_parse into t_program to use the int *arr
init_threads
1. Full sleep function
2. Full thinking function
3. Full eat function
Logic to handl forks per each philo
4. set the order of actions per philo (odd or even)
Set termination condition:
    -end_condition function
    -sim_stop
    -kill_philo
    -clean_up
    -lifes monitor
    -make general the mutex error of forks to all
    -check_end_conditions

WISH to
check if all the structs are malloc correctly and !malloc error



LEFT FORK = index i 
RIGHT FORK = index (i + 1)%N then the last philo will take first the right